## 指令：

### 1： 内容渲染指令、

#### （1）：v-text 

​		缺点：覆盖元素中的默认内容

#### （2）： {{}}

​		插值只能用在元素的内容节点，无法用在属性节点

#### （3）： v-html

​		用处： 把带有HTML标签的字符串，渲染为真正的DOM元素

### 2.属性绑定指令

#### (1): v-bind:

简写：@

#### （2）@click="show"和@"click="show(传参)

#### （3）内置的变量 

#### Sevent --- @click="show(3,Sevent)"

#### （4）事件修饰符：

.prevent

阻止默认事件（例如：阻止a链接的跳转，阻止变量的提交等）

.stop

（阻止事件冒泡）

.capture

（以捕获模式触发当前的事件处理函数）由外到内

.once

（绑定的事件只触发一次）

.self

（只有在event.target是当前元素自身时触发事件处理函数）

#### （5）按键修饰符

.sec

.enter

### 3.双向指令绑定指令

#### （1）： v-model

只能用在表单元素上

#### （2）：修饰符

.number

自动将用户的输入值转为数值类型

eg：<input v-model.number="age">

.trim

自动过滤用户输入的收尾空白字符

<input v-model.trim="msg"/>

.lazy

在”change“时而非”input“时更新

<input v-model.lazy="msg"/>

### 4.循环渲染指令

#### （1）v-for="(item, index) in 数组"

#### （2）：key="item.id"

####    (3)拿索引当key没有意义

### 5.条件渲染指令

#### （1）v-if和else



v-if：动态创建和移除Dom元素，从而控制元素再页面上的显示与隐藏

v-else：指令回动态的为元素添加或移除style="display:none;"样式，从而控制元素的显示与隐藏

**总结：v-if有更高的切换开销，而v-show有更高的初始渲染开销**

#### （2）v-else-if

### 6.key

#### （1）注意事项

1.key的值只能是字符串或数字类型

2.key的值必须具有唯一性（即：key的值不能重复）

3.建议把数据项id属性的值作为key的值（因为id属性的值具有唯一性）

4.使用index的值当作key的值没有任何意义（应为index的值不具有唯一性）

5.建议使用v-for指令时一定要指定key的值（既提升性能，又防止列表状态紊乱）

### 7.过滤器（Filters）

常用于文本格式化

**过滤器应该被添加再js表达式的尾部，由”管道符“进行调用**

eg：

![image-20230413203951639](C:\Users\26424\AppData\Roaming\Typora\typora-user-images\image-20230413203951639.png)

#### （1）全局过滤器

Vue.filter("名字"，function（过滤器前面的值）)

#### （2）私有过滤器

定义到组件的filters节点之下

#### （3）调用

{{message | dateFormat}}

# SPA-单页应用程序

## 1.特点

（1）单页面应用程序将所有的功能局限于一个web页面中仅在web页面初始化时加载相应的资源。

（2）一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转。而是利用JS动态的变换HTML的内容，从而实现也买你与用户的交互。

## 2.优点

**（1）：良好的交互体验**

单页应用的内容的改变不需要重新加载整个页面

获取数据也是通过Ajax异步获取

没有页面之间的跳转，不会出现”白屏现象“

**（2）良好的前后端工作分离模式**

后端专注于提供API接口，更容易实现API接口的复用

前端专注于页面的渲染，更有利于前端工程化的开发

**（3）减轻服务器的压力**

服务器只提供数据，不负责页面的合成雨逻辑的处理，吞吐能力回提高几倍

## 3.缺点

**（1）首屏加载慢**

路由加载慢

代码压缩

CDN加速

网络传输压缩

（**2）不利于SEO**

SSR服务器端渲染



# 侦听器

## 1.定义

**watch侦听器允许开发者监视数据的变化，从而正对数据的变化做特定的操作**

## 2.基本语法

方法格式：

简单： username（newVal.oldVal){},

对象格式：handler（newVal, oldVal）,{}

deep:ture

immediate选项: ture

## 3.计算属性VS侦听器

计算属性和侦听器侧重的应用场景不同：

计算属性侧重于监听多个值的变化，最终计算并返回一个新值

侦听器侧重于监听单个数据的变化，最终执行特定的业务处理，不需要有任何返回值



## 4.computed

1在定义的时候，要定义为function

2.在使用的时候，当作普通属性使用即可

​			在template模板机构中也可以使用

​			在methods方法中，也可以使用----this计算属性的名字

3.要return一个计算的结果

4.只要任何一个以来的数据项发生了变化，计算属性就会重新旧值

## 3.vue-cli

1.全局安装  ---npm install @vue/cli -g

2.创建项目  --vue  create 项目的名称

3.组件的构成

（1）.template

只能有唯一的根节点

（2）。script

export default{}

vue中的data必须事方法

（3）.style

启用less语法 lang=”less“

防止组件之间样式的冲突---scoped

## 4.props

**props是组件的自定义属性，组件的使用者可以通过props把数据传递到子组件内部，供子组件内部进行使用**

**在封装vue组件时，可以把动态的数据项声明为props自定义属性，自定义属性可以咋当前组件的模板结构中被直接使用**

**如果父组件给子组件传递了未声明的props属性，则这些属性会被忽略没无法被子组件使用。**

### （1）.极大的提高了组件的复用性

原则：

（1）组件的DOM结构，Style样式要尽量复用

（2）组件中要展示的数据，尽量由组件的使用者提供

### （2）.定义props两种格式

(1)数组格式

简单

props:['link']

(2)对象格式

定义的时候稍微复杂

props{

init: {

trpe: Number,

default: 0,

requires: true

}

}

（3)props是只读的，因此在项目开发中，不要直接把props的值，”转存“到data中，就可以进行修改他的值

### （3）.总结

1.能够指代哦如何对props进行验证

数组格式、对象格式

type/default/required/validator

2.能够知道如何使用计算属性

computer节点、必须return一个结果、缓存计算结果

3.能够知道如何为组件绑定自定义事件

v-on绑定自定义事件、emits、$emit（）

4.能够知道如何在组件上使用v-model

应用场景：实现组件内外的数据同步

v-model：props名称、emits、$emit('update:props名称')

## 5.生命周期

概念： 每个组件从创建到运行到销毁的一个过程，强调的是一个时间段

1.组件运行的生命周期

组件从创建=>运行（渲染）=>销毁的整个过程，强调的是一个时间段 

2.如何监听组件的不同时刻

vue框架为组件内置了不同时刻的声明周期函数，声明周期函数会伴随着组件的运行而自动调用。

（1）当组件在内存中被创建完毕之后，会自动调用created函数

（2）当组件被成功的渲染到页面上之后，会自动调用mounted函数

（3）当组件被销毁完毕之后，会自动调用unmounted函数

3.如何监听组件的更新

当组件的data数据更新之后，vue会自动重新渲染组件的DOM结构，从而保证View视图展示的数据和Model数据源保持一致。

当组件被重新渲染之后，会自动调用updated声明周期函数。

4.组件中全部的声明周期函数

![image-20230418194159396](C:\Users\26424\AppData\Roaming\Typora\typora-user-images\image-20230418194159396.png)



## 6.生命周期函数

1.概念： 在生命周期的不同阶段，会按次序，自动依次知行的函数，叫做生命周期函数，强调的是时间点

2.三个阶段

（1）创建阶段

beforeCreate

created---发起Ajax最早的时机，请求数据

beforeMount

mounted 组件第一次被渲染到浏览器中        操作DOM元素

（3）销毁阶段

beforeDestroy

destroyed

## 7.组件之间的数据共享

1.父到子---自定义属性

子组件中，通过props来自定义属性

父组件中，负责把数据，通过v-bind绑定给予组件

2.子到父---自定义事件

​	在子组件中调用this。Semit（）来触发自定义事件

​			参数1：字符串，表示自定义事件的名称

​			参数2：值，要发送给父组件的数据

​	在父组件中，通过v-on：来绑定自定义事件，并提供一个事件处理函数。通过事件处理函数的形参，接收到子组件船体过来的数据。

3.兄弟组件共享数据-----EventBus

（1）数据发送方--bus.Semit（要出发的事件的名字，要发送的数据）

（2）EventBus模块

创建vue的实例对象new Vue（）

向外导出Vue的实例对象---export default new Vue()

(3)数据接收方：

导入eventBus.js---import bus form './eventBus.js'

 bus.Son（要生命自定义事件的名字，事件的处理函数）

通过事件处理函数的形参，可以接收到发送过来的数据

在数据接收方的creatrd生命周期函数中，调用bus。Son（）方法

# 组件上的v-model

## 1.为什么要使用v-model

v-model是双向数据绑定指令，当需要俄日胡组件内外数据的同步时，可以在组件上使用v-model指令

## 2.组件上使用v-model的步骤

### （1）：父向子传递

（1）：父组件通过v-bind：属性绑定的形势，把数据传递给子组件

（2）： 子组件中，通过props接收父组件传递过来的数据

## （2）子向父传递

（1）在v-bind：指令之前添加v-model指令

（2）在子组件中声明emits自定义事件，格式为update:xxx

（3）调用$emit（）触发字定义事件，更新父组件中的数据